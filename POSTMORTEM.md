# An [Advent of Code 2021](https://adventofcode.com/2021) in [Zig](https://ziglang.org/) Postmortem

Advent of Code 2021 is complete, and having been inspired by [Neil](https://github.com/sheredom)'s [AoC+Zig review](https://www.duskborn.com/posts/2021-aoc-zig/) from earlier this week, I figured I could share my own thoughts on this language with which I was entirely unacquainted just a month and a half ago, and about which I now have Opinions(tm).

The short version: I like it! I like it enough to [sponsor](https://ziglang.org/zsf/) Zig's future development. I'm no connoisseur of indie programming languages, and I'm looking for something more than a novel approach to a familiar problem. I can imagine a world where I'm happily using Zig on a daily basis. It may well be the worthy C successor I've been dreaming of. I wouldn't endorse it for professional use yet until a stable 1.0 release (and [neither do they](https://ziglang.org/download/0.9.0/release-notes.html#This-Release-Contains-Bugs)), but it already seems perfectly serviceable for personal projects, and looks to have the development momentum necessary to reach escape velocity from niche-language status.

## Where I'm Coming From

My specific programming background will likely inform what I like and don't like about Zig, just as your background should inform how much credibility you place in my thoroughly-biased opinions. So, here's a quick summary of the type of code I tend to write, and the languages I already know (and can't help but compare Zig to). Feel free to skip to the next section if you're impatient to get to pros & cons.

I've been programming for 30 years, mostly on large real-time projects (AAA games, 3D graphics APIs, etc.) written in **C and C++**. I have no shortage of nostalgia for both of these languages, but these days I can't really bear to look at either of them. C is like my favorite book/album/game from when I was a teenager; it may've been mind-blowingly great at the time, but looking at with a few more decades of accumulated experience, all I can see is how much I (and my tastes and expectations) have changed, and how it hasn't changed at all to keep up with them. Meanwhile, C++ is like a dear childhood friend whose personal politics have gradually drifted so far out of alignment with my own that even the briefest interaction just leaves me furious and exhausted. I plan to write as little C/C++ code as possible for the remainder of my programming career, which at this stage may actually be a viable (if immensely privileged) goal.

I've been using **Python** casually for ~15 years, mostly for [small](https://github.com/cdwfs/efit)- to [medium](https://github.com/cdwfs/pyaiml)-sized personal projects, but never professionally (or even in a codebase with more than one developer). My instincts are still rooted in archaic 2.x-era idioms, and I've never evolved beyond `print()`-debugging. Python remains my tool of choice when I want to bang out a quick <100-line throwaway script without having to worry about raw performance, or buildsystems, or third-party dependencies (since [Python's standard library](https://docs.python.org/3/library/index.html) includes almost every battery I could possibly reach for). I'm unlikely to tackle a larger problem in Python; I don't like how weak/duck typing forces me to keep so much global context in my head in order to reason about anything effectively.

Since joining [Unity](https://unity.com) in 2018, most of the code I've written for work has naturally been **C#** (which I [learned](https://github.com/cdwfs/advent2018) through completing [Advent of Code 2018](https://adventofcode.com/2018)). I still don't feel like I know C# especially well, partially because the style of C# we use on the [DOTS](https://unity.com/dots) team actively avoids most of the language's idiomatic best practices. We prefer to use only the Burst-compatible subset of C#, because Burst's output is routinely ~10x-100x faster than Mono's, and that level of speed-up is worth eschewing the usual managed nonsense and jumping through a few hoops for. I'm comfortable enough with the language to get my job done, but there are plenty of things about it that irk me (even within the constraints of Burst-compatibility).

For [AoC 2019](https://adventofcode.com/2019) I [used](https://github.com/cdwfs/advent2019) plain, vanilla **JavaScript** (no third-party packages or frameworks). I've used JS for a few small toy projects (e.g. a [chaos bag simulator for the Arkham Horror Living Card Game](https://github.com/cdwfs/chaosbag), and a [shadertoy-for-audio playground](https://github.com/cdwfs/wavertoy)), but have no plans to use it professionally. For me, JS fills a similar niche as Python; good for smaller tasks (in this case, ones I want to publish to the web instead of one-off utility scripts for my own use), but too much of a hassle to debug at scale. And I have _zero_ interest in boarding the trendy-web-framework-of-the-week treadmill.

For [AoC 2020](https://adventofcode.com/2020) I [learned](https://github.com/cdwfs/advent2020) **Rust**. I was looking for an alternative to C++ for larger, industrial-grade projects (the world of native binaries and hard performance requirements), and had seen a ton of positive buzz from my gamedev peers. My month with Rust was mostly positive; It was my first real hint of what a post-C++ professional-grade language might look like. I loved `cargo` as a first-class buildsystem and package manager, and [clippy](https://github.com/rust-lang/rust-clippy) as a real-time guide towards higher-quality, more idiomatic Rust code. On the other hand, I never really got the hang of the borrow checker (nor did AoC involve the sort of problems where dangling references were an issue), so it mostly felt like something I was fighting against to get my code to compile rather than a productivity-saving tool. And I never managed to wrap my head around the various string representations. I didn't _hate_ Rust, but it's already starting to give me the same intimidatingly-complex vibe that I've been getting from C++ for the last 10 years or so. Perhaps tellingly, I haven't written a single line of Rust code since the end of AoC 2020.

...which brings us to [AoC 2021](https://adventofcode.com/2021)! As November rolled around, I still wasn't sure what language I'd be using this year. I was tempted to revisit Rust, to see if I could get over the hump into something closer to fluency. But I also appreciate the annual opportunity to try something new. And then, while (virtually) attending Handmade Seattle 2021, I got my first exposure to **Zig** (including [@andrewrk](https://github.com/andrewrk)'s talk, [A Practical Guide to Applying Data-Oriented Design](https://media.handmade-seattle.com/practical-data-oriented-design/), which features the most legendary mid-talk wardrobe change I've seen in recent memory). The language sounded like it could be the simple, modern C/C++ replacement I've been looking for. My interest was piqued, and now (7 weeks later, as I'm writing this) I've just finished another year of AoC using Zig. Bring on the pros & cons!

## Good Stuff

- **No hidden control flow.** It's one of the very first things you see on the [ziglang.org](https://ziglang.org), and a huge selling point for me. C++ operator overloading makes me nervous in theory, and C# properties are actively infuriating in actual practice. I love Zig's policy that if it doesn't look like a function call, it's not a function call.

- **Relatively shallow learning curve.** Basic syntax-wise, Zig doesn't feel like a huge departure from the C/C++ family. That was a plus for me; ymmv. By day 10 of AoC, I was solving problems without consulting manual at all.

- **The little things.** Zig has a bunch of nice little features that I appreciate coming from C/C++/C#, even if they're not necessarily groundbreaking or original. `break`ing or `continue`ing an outer loop from a deeply nested loop. Capturing the loop index when iterating over a collection. Named struct field initialization (falling back on default values if provided). Arbitrary bit sizes for ints and floats (including, hilariously, built-in support for up to 65536-bit integer variables, though in practice this currently just yields an LLVM compile error). Optional inferred types for variable declaractions, where possible (function parameters and return types are explicit, though, afaik). 

- **SIMD vectors as a first-class type.** The code I write tends to involve a lot of 3D math (3D points/vectors, 4x4 transformation matrices, and enough linear algebra to smoosh them together). This is usually the one place I have to grudgingly accept the necessity of operator overloading; writing complex matrix/vector expressions in a language that doesn't overload the arithmetic operators (e.g. JavaScript) is maddening. Zig hits the happy medium; it has built-in support for SIMD vector operations (via [`std.meta.Vector`](https://ziglang.org/documentation/0.9.0/#Vectors)), without allowing arbitrary overloading. I confess that I only just noticed this feature while writing this postmortem and haven't played with it yet (docs prior to 0.9.0 glossed over it in a few sentences and made it sound somewhat less than fully baked), but now that I know it's here, I _definitely_ intend to go back and retrofit it into a few of my AoC solutions. It doesn't seem like matrix multiplication would be supported, but maybe that's too niche for a core language feature.

- **built-in structure-of-array (SoA) support.** The [`std.MultiArrayList`](https://ziglang.org/documentation/0.9.0/std/#std;MultiArrayList) type gives you an SoA representation of any arbitrary struct, suitable for data-orienting all the things. This seems like it would play extremely nicely with the SIMD/Vector API.

- **Built-in build/test infrastructure.** This is hardly unique among modern programming languages, but one area where C and C++ still come up short & have to rely on a third-party ecosystem. Zig programs are built using `build.zig` programs (which are themselves written in Zig), and adding inline unit tests is as simple as `test "test name" { code goes here }`, right next to the function you're testing if you'd like. If I never have to write another `CMakeLists.txt` file again...

- **Forced safety.** Zig forces you to avoid (or handle) all sorts of subtle potential errors that would otherwise quietly slip into a codebase. It doesn't go full-on Rust-borrow-checking, but I do appreciate that many of C/C++'s most egregious potential footgun moments are flagged at runtime (if not caught and rejected at compile time). All integer and float types are explicitly sized; no wondering whether an `int` is 32 bits or 64 on your target platform. The [Optionals](https://ziglang.org/documentation/0.9.0/#Optionals) feature is a useful way to avoid null pointers/references. [Error unions](https://ziglang.org/documentation/0.9.0/#Error-Union-Type) are a great alternative to exceptions or ignorable error codes. Ignoring a function's return value (or an error union/optional) is a compile error. Using a signed integer to index an array is an error. Slices and arrays are bounds-checked. Integer overflow/underflow is an error (which you can avoid by explicitly requesting saturate or two's-complement-wrapping semantics with the `+|` or `+%` operators, respectively). Using an uninitialized variable is a compile error. Shadowing a previous variable declaration is an error. And on, and on...

- **Explicit (but safe) memory management.** Allocating heap memory in Zig feels appropriately expensive, and can only be done through a `std.mem.Allocator` instance. If you don't have an `Allocator`, you can't allocate heap memory. And you often don't need to, thanks to types like `std.BoundedArray` (which provides a variable-size array with a compile-time max capacity, and thus requires no heap allocation or explicit cleanup). For cases where dynamic memory allocation isn't totally avoidable, a number of useful allocators are provided out-of-the-box: a testing allocator with leak and use-after-free detection, fixed-buffer allocators for establishing an absolute upper bound on heap usage, an arena allocator that periodically frees all of its contents (e.g. once per frame), and of course a general-purpose allocator for when its flexibility is warranted.

## Pain Points

While I didn't hit any fundamental dealbreakers for AoC purposes, there were a few issues I ran into that ranged from annoyances to potential future headaches.

- **Incomplete standard library documentation.** This is enough of a known issue that there's a banner right there at the top of every docs page:
  > These docs are experimental. Progress depends on the self-hosted compiler, consider reading the stdlib source in the meantime.

  And they're right; reading the stdlib source code was generally enough to get me what I needed to know. But it's still nice to have that browsable/searchable reference guide on the web. It'll get there eventually, but it's definitely not there today.

- **Incomplete Debugger/IDE integration.** I used [VS Code](https://code.visualstudio.com/), [ZLS](https://github.com/zigtools/zls), and two VSCode extensions ([@prime31](https://github.com/prime31)'s [Zig](https://marketplace.visualstudio.com/items?itemName=prime31.zig), and [ZLS for VSCode](https://marketplace.visualstudio.com/items?itemName=AugusteRame.zls-vscode)). This (plus a bit of [settings.json hackery](https://github.com/cdwfs/advent2021#useful-vscode-settings-language-independent)) was enough to get basic IDE functionality working for Zig code: syntax highlighting, Alt+G to go to definition, debugger breakpoints and single stepping, etc. It was sufficient for AoC purposes, but there were some rough edges that I'm sure would become major productivity sinks on a larger project:
  - Suggestions for fields/methods on `foo` after typing `foo.` were frequently either incomplete (some public fields/methods wouldn't be suggested) or overcomplete (fields/methods from other types would be included in the list).
  - Unreferenced variables/fields/functions are compiled away with extreme prejudice (and thus unavailable to inspect in the debugger), unless you go out of your way to reference them (e.g. with `std.mem.doNotOptimizeAway()`). This mostly came up while trying to get some unfamiliar feature working, without fully understanding how it's supposed to be used, and yet being unable to inspect the result of some incomplete computation in the debugger to see what I should do next.
  - Single-stepping feels too tedious. Stepping through code in the debugger requires a lot more steps than decades of Visual Studio experience have trained me to expect. Maybe it's being helpful and stopping at every possible intermediate result, rather than once per source code line? Maybe I'll come around to appreciating that someday? 
  - The style warnings from ZLS were handy, but they triggered frequently enough on files in the standard library that problems in my own code were easy to lose in the noise.
  
- **Some simple operations feel overly verbose.** As a flip side of the "forced safety" point above, I did have to lean much harder than expected on functions like `@as()`, `@intCast()`, `@truncate()`, `@enumToInt()`, `catch unreachable`, and friends in order to make the compiler happy. This frequently turned a (conceptually) simple expression into a line and a half of fiddly pseudo-function-calls. I'm on the fence about whether this is a bad thing or not; would I really prefer if all these hidden sign extensions, truncations, and typecasts were implicit? Probably not.
  - One special-case worth mentioning: Zig is _very_ aggressive about wanting to push your program's execution from runtime to compile-time where possible. On balance, that's probably a good thing! But the price of this enthusiasm is that I frequently ended up having to explicitly opt out of compile-time processing with a typecast. A common example is in unit tests: I'd write code like `try std.testing.expectEqual(7, runtimeVariableThatShouldBe7);`, which the compiler would reject because it assumes `7` is a `comptime_int`, which means it wants `variableThatShouldBe7` to be `comptime_int` as well, but it can't cast the runtime type to a compile-time one. The workaround is to wrap the literal in `@as(i64, 7)`, which isn't the end of the world. But sometimes I do wish for a way to opt out of comptime within some block, in cases where readability trumps maximally-efficient codegen.
  
- **No single-line C-style for()-loop equivalent.** It's minor, but I kinda miss a one-line "declare and initialize an integer variable, and run a for loop with that variable over some range". Zig automatically provides a loop counter when you're iterating over a slice or collection, but if you just want `for(int i=first, i<=end, ++i)` you have to declare and initialize `i` outside the loop (_and_ remember to re-initialize it if you copy/paste the same loop further down the same block, which is totally not a bug I hit multiple times in the last month). I understand the [rationale](https://twitter.com/cachecoherent/status/1475534711170768901) for this feature's absence, but I think I'd still prefer "ugly but functional" to "just flat-out not possible". (okay, [maybe not _entirely_ impossible...](https://twitter.com/cachecoherent/status/1475536908755292173))

## TBD

Advent of Code is great for getting some real exposure to a new programming language, but that exposure is mostly limited to the core workflow of implementing (and debugging) algorithms, running on data that's already in memory. That's a good thing; on a good day, that _should_ be how the vast majority of one's programming time is spent. But it's not the whole picture; there are a ton of critical tasks and workflows that AoC didn't give me an excuse to explore in Zig. They could be great, they could be a total trash fire; either way I'll have to explore them through other projects:

- **Non-trivial build scripting.** All I needed for AoC was the basic out-of-the-box "compile `dayNN.zig` to `dayNN.exe`"; I want to take a stab at larger, more realistic workloads. This will also give me a better sense of typical compilation time on larger projects. I'm also eager to check out the built-in cross-compilation support
- **The Vector/SIMD API.** See above.
- **File I/O.** For AoC, I dodged file input by using `@embedFile()`, and the only output I needed was `std.debug.print()`.
- **Profiling.** There's a built-in `std.time.Timer` for timing blocks of code down to nanosecond precision (subject to the actual hardware timer's precision, of course); I'm not sure yet what tools are available for more professional-grade sampling or hierarchical profiling.
- **Threads/async.** I see the support is there; I just haven't had an excuse to use it yet.
- **comptime.** Mostly-transparent support for compile-time programming is one of Zig's signature features; I should check it out at some point.
- **Third-party packages / dependency management.** I didn't use any third-party code for AoC, so I'm not sure what the story is here, but I gather that an official package manager is on the roadmap for Zig's eventual 1.0 release.
- **C <-> Zig.** According to the docs, this is relatively easy (Zig's compiler can just consume C code directly, and Zig has features like `@cImport()` and `@cInclude()` to directly pull C APIs into Zig without the need for an explicit binding layer.) Gradually converting an existing C project to Zig one source file at a time is an explicitly supported use case. Being able to trivially pull [single-header C libraries](https://github.com/nothings/stb) into Zig projects sounds _fantastic._

## Curious?

If I've managed to convince you that Zig is worth a look, here are a some resources to check out as a first step:

- [ziglearn.org](https://ziglearn.org/) is a quick overview of the core language features.
- [Ziglings](https://github.com/ratfactor/ziglings) is a series of short exercises. Learn Zig by fixing broken programs.
- The [Zig Language Reference](https://ziglang.org/documentation/master/) is quite readable; it's mostly in the form of commented unit tests and their output, so you can see exactly how a given feature works in real code (and just as importantly, how it looks when it _doesn't_ work).
